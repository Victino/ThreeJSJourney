Materials
recapping on color, alpha(opacity), ambient occlusion, height,
normal, metalness, roughness

matcaps
gradients

panes normally dont have a backside,
you can do 
```material.side = THREE.DoubleSide;```
but this is not optimal for performance. 

MeshNormalMaterial
![[Pasted image 20230317211817.png]]
shows the direction of the geometries
![[Pasted image 20230317211934.png]]

the reason this is good is because we can determine what should be in the light and what should be in the shadow.

flatshading:
![[Pasted image 20230317212109.png]]
flattens facesm, normales wont be interopolated between vertices

THREE.MeshMatcapMaterial() takes colors from a texture and maps them based on the normals?
![[Pasted image 20230317212408.png]]
this way you can simulate light and shadow without adding it.

![[Pasted image 20230317212453.png]]
while matcap is:
![[Pasted image 20230317212544.png]]

mesh depth material
![[Pasted image 20230317212834.png]]
the closer a thing to the camera the whiter it is, further is dark. This is good for fog and post prosessing.



Adding light:
```javascript
const ambientLight = new THREE.AmbientLight( 0xffffff, 0.5);
scene.add(ambientLight);

const pointLight = new THREE.PointLight(0xffffff, 0.5);
pointLight.position.x = 2;
pointLight.position.y = 3;
pointLight.position.z = 4;
scene.add(pointLight);
```
Applying lighting with MeshLambertMaterial and MeshPhongMaterial/

you also have material.shininess and material.specular.

then there is MeshToonMaterial for:
![[Pasted image 20230317214141.png]]
toon like colors (think of zelda windwaker?)

Mesh Standard Material
like lambert and phong support lights but more realistic algorithms with roughness and metalness.
![[Pasted image 20230317214621.png]]
