Materials
recapping on color, alpha(opacity), ambient occlusion, height,
normal, metalness, roughness

matcaps
gradients

panes normally dont have a backside,
you can do 
```material.side = THREE.DoubleSide;```
but this is not optimal for performance. 

MeshNormalMaterial
![[Pasted image 20230317211817.png]]
shows the direction of the geometries
![[Pasted image 20230317211934.png]]

the reason this is good is because we can determine what should be in the light and what should be in the shadow.

flatshading:
![[Pasted image 20230317212109.png]]
flattens facesm, normales wont be interopolated between vertices

THREE.MeshMatcapMaterial() takes colors from a texture and maps them based on the normals?
![[Pasted image 20230317212408.png]]
this way you can simulate light and shadow without adding it.

![[Pasted image 20230317212453.png]]
while matcap is:
![[Pasted image 20230317212544.png]]

mesh depth material
![[Pasted image 20230317212834.png]]
the closer a thing to the camera the whiter it is, further is dark. This is good for fog and post prosessing.



Adding light:
```javascript
const ambientLight = new THREE.AmbientLight( 0xffffff, 0.5);
scene.add(ambientLight);

const pointLight = new THREE.PointLight(0xffffff, 0.5);
pointLight.position.x = 2;
pointLight.position.y = 3;
pointLight.position.z = 4;
scene.add(pointLight);
```
Applying lighting with MeshLambertMaterial and MeshPhongMaterial/

you also have material.shininess and material.specular.

then there is MeshToonMaterial for:
![[Pasted image 20230317214141.png]]
toon like colors (think of zelda windwaker?)

Mesh Standard Material
like lambert and phong support lights but more realistic algorithms with roughness and metalness.
![[Pasted image 20230317214621.png]]

mesh standard material uses physically based rendering.. PBR

you can add ambient occlusion maps with material.aoMap = (ao item)
this makes it more clear that ambient occlusion is a shadowing technique used for soft shadow.
![[3-s2.0-B9781558606593500172-f15-16-9781558606593.jpg]]

adding a displacementMap with the height texture
and scaling it property will give height/depth to the object, the object does have to have enough vertices however, this will not work when you have a plane with 2 vertices.

![[Pasted image 20230319162845.png]]


points material can be used for particles, this will be covered in other lesson.

shadermaterial and rawshadermaterial can be used for creating own materials not in base three.js?

Environment Map is an iage of what is surrounding a scene. It can be used for reflection and refraction but also general lighting. This is supported by meshstandardmaterial.

to do so we need different type of loader, we now used textureLoader but this time CubeTextureLoader (because a skybox?)

```javascript
const environmentMapTexture = cubeTextureLoader.load([
    '/textures/environmentMaps/0/px.jpg',
    '/textures/environmentMaps/0/nx.jpg',
    '/textures/environmentMaps/0/py.jpg',
    '/textures/environmentMaps/0/ny.jpg',
    '/textures/environmentMaps/0/pz.jpg',
    '/textures/environmentMaps/0/nz.jpg'
]);
```
need to know the positions of what images for the environment map.
![[Pasted image 20230319165300.png]]
gives these reflections based on environment. can be used foor puddles of water and mirrors.

![[Pasted image 20230319165453.png]]
by increasing metalness and decreasing roughness it will reflect  clearer. this will not show camera tho just the images.