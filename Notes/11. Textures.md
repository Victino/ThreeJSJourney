Textures

Color/Albedo
most simple one, a color applied to the geometry

Alpha
grayscale image, white is visible, black not

Height/Displacement
grayscale
move the vertices to create some relief
not enough subdivision
![[Pasted image 20230304150520.png]]
problem is you a enough subdisivions

Normal
Add details regarding to lighting
doesnt need subdivision for applying textures
better performance because you dont need many vertices

Ambient Occlusion
grayscale image
add fake shadows
not physically accurate
help create contract and details

Metalness
White is metallic
black is non-metalic
mostly for reflection

Roughness
in duo with metalness
white rough, black smooth
light dissipation, cant see light bounce on carpet

Textures follow PBR
Phyically based rendering

Loading Image Url
```javascript
const image = new Image();
const texture = new THREE.Texture(image);
image.onload = () =>{
     texture.needsUpdate = true;
        console.log(texture);
    }
image.src = '/textures/door/color.jpg'

const material = new THREE.MeshBasicMaterial({ map: texture })
```

```javascript
const textureLoader = new THREE.TextureLoader();
const texture = textureLoader.load('/textures/door/color.jpg')

const material = new THREE.MeshBasicMaterial({ map: texture })
```


You also have loadingManager
now we only build 1 texture, you can have multiple loadings

```javascript
const loadingManager = new THREE.LoadingManager();

loadingManager.onStart = () => {};
loadingManager.onLoad = () => {};
loadingManager.onProgress = () => {};
loadingManager.onError = () => {};

const textureLoader = new THREE.TextureLoader(loadingManager);
const colorTexture = textureLoader.load('/textures/door/color.jpg');
const alphaTexture = textureLoader.load('/textures/door/alpha.jpg');
const heightTexture = textureLoader.load('/textures/door/height.jpg');
const normalTexture = textureLoader.load('/textures/door/normal.jpg');
const ambientOcclusionTexture = textureLoader.Load('/textures/door/ambientOcclusion.jpg');
const metalnessTexture = textureLoader.Load('/textures/door/metalness.jpg');
const roughnessTexture = textureLoader.Load('textures/door/roughness.jpg');
```


UV wrapping
![[Pasted image 20230305174817.png]]
wrapping texture

// colorTexture.repeat.x = 2;
// colorTexture.repeat.y = 3;
// colorTexture.wrapS = THREE.MirroredRepeatWrapping;
// colorTexture.wrapT = THREE.MirroredRepeatWrapping;
// colorTexture.offset.x = 0.5;
// colorTexture.offset.y = 0.5;
colorTexture.rotation = Math.PI / 4;

![[Pasted image 20230305175107.png]]

mipmapping is this layout of textures

you can use colorTexture.minFilter = THREE.NearestFilter;
if texture isn't big enough it will get blurry, if too big it will be compressed
![[Pasted image 20230305175606.png]]
![[Pasted image 20230305175648.png]]

if  you use magFilter instead:
![[Pasted image 20230305175819.png]]
wil be
![[Pasted image 20230305175832.png]]

minfilter doesnt need mipmapping on NearestFilter

3 things to keep in mind:
1. weight, lot of textures will have to wait for all textures to load
jpg is lossy compressing usually lighter
png lossless compression is heavier looks better

2. Size
   Gpu has limitation, resizing textures to be smaller is better for performance
   you need power of 2 resolution, because the images get divided by 2 every time.

3. The Data
   transparancy within meterial is possible, but only with png not jpg.
   for normal texture you need exact values of pixels
   sometimes we can combine different data into one texture by using rgb and alpha channels
![[Pasted image 20230305181140.png]]

